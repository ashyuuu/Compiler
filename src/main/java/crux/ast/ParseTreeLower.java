package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.ir.insts.BinaryOperator;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where declarations will be by DeclarationVisitor Class Statements will be resolved by
 * StatementVisitor Class Expressions will be resolved by ExpressionVisitor Class
 */

public final class ParseTreeLower {
  private final DeclarationVisitor declarationVisitor = new DeclarationVisitor();
  private final StatementVisitor statementVisitor = new StatementVisitor();
  private final ExpressionVisitor expressionVisitor = new ExpressionVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }



  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   * 
   * @return a {@link DeclarationList} object representing the top-level AST.
   */

  public DeclarationList lower(CruxParser.ProgramContext program) {
      List<Declaration> list = new ArrayList<Declaration>();
      for (CruxParser.DeclarationContext dlc : program.declarationList().declaration()){
          list.add(dlc.accept(declarationVisitor));
      }
      return new DeclarationList(makePosition(program), list);
  }

  /**
   * Lower statement list by lower individual statement into AST.
   * 
   * @return a {@link StatementList} AST object.
   */

  private StatementList lower(CruxParser.StatementListContext statementList) {
      List<Statement> list = new ArrayList<Statement>();
      for (CruxParser.StatementContext slc : statementList.statement()){
          list.add(slc.accept(statementVisitor));
      }
      return new StatementList(makePosition(statementList), list);
  }


  /**
   * Similar to {@link #lower(CruxParser.StatementListContext)}, but handles symbol table as well.
   * 
   * @return a {@link StatementList} AST object.
   */


   private StatementList lower(CruxParser.StatementBlockContext statementBlock) {
       List<Statement> list = new ArrayList<Statement>();
       int i = 0;
       for (CruxParser.StatementContext slc : statementBlock.statementList().statement()){
//           if(slc.accept(statementVisitor) == null)
//               System.out.println(i==statementBlock.statementList().statement().size()-1);
               //System.out.println("\n\n\n1\n\n\n");
           list.add(slc.accept(statementVisitor));
           i++;
       }

       return new StatementList(makePosition(statementBlock), list);
   }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclarationVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}
     * 
     * @return an AST {@link VariableDeclaration}
     */


    @Override
    public VariableDeclaration visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx) {
//        TypeChecker t = new TypeChecker();
        Type t = null;
        IntType intType = new IntType();
        BoolType boolType = new BoolType();

        if (ctx.type().Identifier().getText().equals("int")){
            t = intType;
        } else if (ctx.type().Identifier().getText().equals("bool")){
            t = boolType;
        }

        Symbol s = symTab.add(makePosition(ctx),ctx.Identifier().getText(),t);
        return new VariableDeclaration(makePosition(ctx),s);
//        if (!hasEncounteredError()){
//            return new VariableDeclaration(makePosition(ctx),s);
//        }
//        return null;
    }


    /**
     * Visit a parse tree array declaration and creates an AST {@link ArrayDeclaration}
     * 
     * @return an AST {@link ArrayDeclaration}
     */


     @Override
     public Declaration visitArrayDeclaration(CruxParser.ArrayDeclarationContext ctx) {
         ArrayType t = null;
         if (ctx.type().getText().equals("int")){
             t = new ArrayType(Long.parseLong(ctx.Integer().getText()),new IntType());
         } else if (ctx.type().getText().equals("bool")) {
             t = new ArrayType(Long.parseLong(ctx.Integer().getText()),new BoolType());
         }

         Symbol s = symTab.add(makePosition(ctx),ctx.Identifier().getText(),t);
         return new ArrayDeclaration(makePosition(ctx),s);
//         if (!hasEncounteredError()){
//             return new ArrayDeclaration(makePosition(ctx),s);
//         }
//         return null;
     }


    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     * 
     * @return an AST {@link FunctionDefinition}
     */


     @Override
     public Declaration visitFunctionDefinition(CruxParser.FunctionDefinitionContext ctx) {
         Position pos = makePosition(ctx);
         Symbol s = null;
         TypeList tl = new TypeList();
         for(CruxParser.ParameterContext param : ctx.parameterList().parameter()) {
             if (param.type().Identifier().getText().equals("bool")){
                 tl.append(new BoolType());
             } else if (param.type().Identifier().getText().equals("int")){
                 tl.append(new IntType());
             }
         }
         Type ret = null;
         if (ctx.type().getText().equals("bool")){
             ret = new BoolType();
         } else if (ctx.type().getText().equals("int")){
             ret = new IntType();
         } else if (ctx.type().getText().equals("void")){
             ret = new VoidType();
         }
         s = symTab.add(makePosition(ctx),ctx.Identifier().getText(), new FuncType(tl, ret));

         symTab.enter();
         List<Symbol> params = new ArrayList<Symbol>();
         for (int i = 0; i < ctx.parameterList().parameter().size(); i++) {
             switch (ctx.parameterList().parameter(i).type().Identifier().getText()) {
                 case "bool":
                     params.add(symTab.add(makePosition(ctx), ctx.parameterList().parameter(i).Identifier().getText(), new BoolType()));
                     break;
                 case "int":
                     params.add(symTab.add(makePosition(ctx), ctx.parameterList().parameter(i).Identifier().getText(), new IntType()));
                     break;
             }
         }
         StatementList block = lower(ctx.statementBlock());
         symTab.exit();
         return new FunctionDefinition(pos,s,params,block);
     }

  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Statement}
   */

  private final class StatementVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree variable declaration and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to
     * {@link DeclarationVisitor#visitArrayDeclaration(CruxParser.ArrayDeclarationContext)} which we
     * implement earlier.
     * 
     * @return an AST {@link VariableDeclaration}
     */


     @Override
     public Statement visitVariableDeclaration(CruxParser.VariableDeclarationContext ctx) {
         return declarationVisitor.visitVariableDeclaration(ctx);
     }

    
    /**
     * Visit a parse tree assignment statement and create an AST {@link Assignment}
     * 
     * @return an AST {@link Assignment}
     */


     @Override
     public Statement visitAssignmentStatement(CruxParser.AssignmentStatementContext ctx) {
         Expression lhs = ctx.designator().accept(expressionVisitor);
         Expression rhs = ctx.expression0().accept(expressionVisitor);
         if (ctx.designator() == null)
             System.out.println("\n\n\n2\n\n\n");
         return new Assignment(makePosition(ctx), lhs, rhs);
     }


    /**
     * Visit a parse tree assignment nosemi statement and create an AST {@link Assignment}
     * 
     * @return an AST {@link Assignment}
     */


     @Override
     public Statement visitAssignmentStatementNoSemi(CruxParser.AssignmentStatementNoSemiContext ctx) {
         Expression lhs = ctx.designator().accept(expressionVisitor);
         Expression rhs = ctx.expression0().accept(expressionVisitor);
         return new Assignment(makePosition(ctx), lhs, rhs);
     }


    /**
     * Visit a parse tree call statement and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statement}, we simply delegate this to
     * {@link ExpressionVisitor#visitCallExpression(CruxParser.CallExpressionContext)} that we will
     * implement later.
     * 
     * @return an AST {@link Call}
     */


     @Override
     public Statement visitCallStatement(CruxParser.CallStatementContext ctx) {
         return expressionVisitor.visitCallExpression(ctx.callExpression());
//         return visitCallExpression(ctx.callExpression());
     }


    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     * 
     * @return an AST {@link IfElseBranch}
     */


     @Override
     public Statement visitIfStatement(CruxParser.IfStatementContext ctx) {
         symTab.enter();
         Position pos = makePosition(ctx);
         Expression cond = ctx.expression0().accept(expressionVisitor);
         if (ctx.statementBlock().size()==1) {
             StatementList block = lower(ctx.statementBlock(0));
             symTab.exit();
             return new IfElseBranch(pos, cond, block, new StatementList(makePosition(ctx), new ArrayList<Statement>()));
         }
         StatementList l = lower(ctx.statementBlock(0));
         symTab.exit();
         symTab.enter();
         StatementList elseBlock = lower(ctx.statementBlock(1));
         symTab.exit();
         return new IfElseBranch(pos, cond, l, elseBlock);
     }


    /**
     * Visit a parse tree for loop and create an AST {@link For}. You'll going to use a similar
     * techniques as {@link #visitIfStatement(CruxParser.IfStatementContext)} to decompose this
     * construction.
     * 
     * @return an AST {@link For}
     */


     @Override
     public Statement visitForStatement(CruxParser.ForStatementContext ctx) {
         symTab.enter();
         Position pos = makePosition(ctx);
         Assignment one = new Assignment(makePosition(ctx),
                 ctx.assignmentStatement().designator().accept(expressionVisitor),
                 ctx.assignmentStatement().expression0().accept(expressionVisitor));
         Expression exp = ctx.expression0().accept(expressionVisitor);
         Assignment two =   new Assignment(makePosition(ctx),
                 ctx.assignmentStatementNoSemi().designator().accept(expressionVisitor),
                 ctx.assignmentStatementNoSemi().expression0().accept(expressionVisitor));

         StatementList block = lower(ctx.statementBlock());
         symTab.exit();
         return new For(pos, one, exp, two, block);
//         return null;
     }


    /**
     * Visit a parse tree return statement and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     * 
     * @return an AST {@link Return}
     */


     @Override
     public Statement visitReturnStatement(CruxParser.ReturnStatementContext ctx) {
         return new Return(makePosition(ctx), ctx.expression0().accept(expressionVisitor));
     }


    /**
     * Creates a Break node
     */


     @Override
     public Statement visitBreakStatement(CruxParser.BreakStatementContext ctx) {
         return new Break(makePosition(ctx));
     }

  }

  private final class ExpressionVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expression0 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */


     @Override
     public Expression visitExpression0(CruxParser.Expression0Context ctx) {
         if (ctx.op0().size()==0){
             return visit(ctx.expression1(0));
         } else {
             Operation op = null;
             if (ctx.op0(0).getText().equals(">=")  ) {
                 op = Operation.GE;
             } else if (ctx.op0(0).getText().equals("<=")) {
                 op = Operation.LE;
             } else if (ctx.op0(0).getText().equals("!=")) {
                 op = Operation.NE;
             } else if (ctx.op0(0).getText().equals("==")) {
                 op = Operation.EQ;
             } else if (ctx.op0(0).getText().equals(">")) {
                 op = Operation.GT;
             } else if (ctx.op0(0).getText().equals("<")) {
                 op = Operation.LT;
             }
             return new OpExpr(makePosition(ctx), op, visit(ctx.expression1(0)), visit(ctx.expression1(1)));
         }
     }


    /**
     * Parse Expression1 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */


     @Override
     public Expression visitExpression1(CruxParser.Expression1Context ctx) {
         if (ctx.op1()==null){
             return visit(ctx.expression2());
         } else {
             Operation op = null;
             if (ctx.op1().getText().equals("+")){
                 op = Operation.ADD;
             } else if (ctx.op1().getText().equals("-")){
                 op = Operation.SUB;
             } else if (ctx.op1().getText().equals("||")){
                 op = Operation.LOGIC_OR;
             }
             return new OpExpr(makePosition(ctx), op, visit(ctx.expression1()), visit(ctx.expression2()));
         }
     }


    /**
     * Parse Expression2 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */
    

     @Override
     public Expression visitExpression2(CruxParser.Expression2Context ctx) {
         if (ctx.op2()==null){
             return visit(ctx.expression3());
         } else {
             Operation op = null;
             if (ctx.op2().getText().equals("*")){
                 op = Operation.MULT;
             } else if (ctx.op2().getText().equals("/")){
                 op = Operation.DIV;
             } else if (ctx.op2().getText().equals("&&")){
                 op = Operation.LOGIC_AND;
             }
             return new OpExpr(makePosition(ctx), op, visit(ctx.expression2()), visit(ctx.expression3()));
         }
     }


    /**
     * Parse Expression3 to OpExpr Node Parsing the expression should be exactly as described in the
     * grammer
     */


     @Override
     public Expression visitExpression3(CruxParser.Expression3Context ctx) {
         if (ctx.Exclamation() != null) {
             return new OpExpr(makePosition(ctx), Operation.LOGIC_NOT, visit(ctx.expression3()), null);
         } else if (ctx.OpenParen() != null && ctx.CloseParen() != null){
//             Expression left = new OpExpr(makePosition(ctx), null, visit(ctx.OpenParen()), visit(ctx.expression0()));
//             return new OpExpr(makePosition(ctx),null,left,visit(ctx.CloseParen()));
             return visit(ctx.expression0());
         } else if (ctx.designator() != null){
             return visit(ctx.designator());
         } else if (ctx.callExpression() != null){
             return visit(ctx.callExpression());
         } else if (ctx.literal() != null) {
             return visit(ctx.literal());
         }
         return null;
     }


    /**
     * Create an Call Node
     */
     @Override
     public Call visitCallExpression(CruxParser.CallExpressionContext ctx) {
         Symbol s = symTab.lookup(makePosition(ctx),ctx.Identifier().getSymbol().getText());
//         if (!hasEncounteredError()){
//             List<Expression> list = new ArrayList<Expression>();
//             if (ctx.expressionList()==null)
//                 return new Call(makePosition(ctx),s,null);
//             for (CruxParser.Expression0Context e : ctx.expressionList().expression0()){
//                 list.add(visit(e));
//             }
//             return new Call(makePosition(ctx),s,list);
//         }
         List<Expression> expr = new ArrayList<>();
         for (CruxParser.Expression0Context exp : ctx.expressionList().expression0()){
             expr.add(expressionVisitor.visitExpression0(exp));
         }
         return new Call(makePosition(ctx),s,expr);
     }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
        Symbol s = symTab.lookup(makePosition(ctx),ctx.Identifier().getSymbol().getText());
        if (hasEncounteredError()) {
            return null;
        }
        if (ctx.OpenBracket().size()==0){
            return new VarAccess(makePosition(ctx), s);
        } else {
            Expression base = new ArrayAccess(makePosition(ctx), s, visit(ctx.expression0(0)));
            return base;
            //Expression index = visit(ctx.expression0(0));
//            for (int i = 1; i < ctx.OpenBracket().size(); i++){
//
//            }
        }
//        Expression lhs = visit(ctx.Identifier());
////        if (lhs == null)
////            System.out.println("\n\n\n3\n\n\n");
//        for (int i = 0; i < ctx.OpenBracket().size(); i++){
//            Expression t1 = new OpExpr(makePosition(ctx),null,visit(ctx.OpenBracket(i)),visit(ctx.expression0(i)));
//            Expression t2 = new OpExpr(makePosition(ctx),null,t1,visit(ctx.CloseBracket(i)));
//            lhs = new OpExpr(makePosition(ctx),null,lhs,t2);
//        }
//        return lhs;
    }


    /**
     * Create an Literal Node
     */

    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
        if (ctx.Integer()!=null)
            return new LiteralInt(makePosition(ctx),Long.parseLong(ctx.getText()));
        else if (ctx.True()!=null)
            return new LiteralBool(makePosition(ctx),true);
        else if (ctx.False()!=null)
            return new LiteralBool(makePosition(ctx),false);
        return null;
    }

  }
}
